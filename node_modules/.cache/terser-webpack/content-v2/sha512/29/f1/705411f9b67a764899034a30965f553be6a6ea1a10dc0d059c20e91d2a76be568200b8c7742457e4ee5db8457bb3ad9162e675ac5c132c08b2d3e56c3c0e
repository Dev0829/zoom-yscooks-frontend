{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{\"44PX\":function(e,t,s){\"use strict\";s.d(t,\"a\",function(){return h}),s.d(t,\"b\",function(){return u}),s.d(t,\"c\",function(){return b});var i=s(\"fXoL\"),n=s(\"ofXK\");function a(e,t){if(1&e){const e=i.Sb();i.Rb(0,\"span\",7),i.Yb(\"click\",function(t){i.pc(e);const s=i.bc().$implicit,n=i.bc();return t.preventDefault(),n.removeTab(s)}),i.xc(1,\" \\u274c\"),i.Qb()}}const l=function(e){return[\"nav-item\",e]};function r(e,t){if(1&e){const e=i.Sb();i.Rb(0,\"li\",3),i.Yb(\"keydown\",function(s){i.pc(e);const n=t.index;return i.bc().keyNavActions(s,n)}),i.Rb(1,\"a\",4),i.Yb(\"click\",function(){return t.$implicit.active=!0}),i.Rb(2,\"span\",5),i.xc(3),i.Qb(),i.vc(4,a,2,0,\"span\",6),i.Qb(),i.Qb()}if(2&e){const e=t.$implicit;i.Db(\"active\",e.active)(\"disabled\",e.disabled),i.hc(\"ngClass\",i.jc(15,l,e.customClass||\"\")),i.zb(1),i.Db(\"active\",e.active)(\"disabled\",e.disabled),i.Ab(\"aria-controls\",e.id?e.id:\"\")(\"aria-selected\",!!e.active)(\"id\",e.id?e.id+\"-link\":\"\"),i.zb(1),i.hc(\"ngTransclude\",e.headingRef),i.zb(1),i.yc(e.heading),i.zb(1),i.hc(\"ngIf\",e.removable)}}const c=[\"*\"];let o=(()=>{class e{constructor(e){this.viewRef=e}set ngTransclude(e){this._ngTransclude=e,e&&this.viewRef.createEmbeddedView(e)}get ngTransclude(){return this._ngTransclude}}return e.\\u0275fac=function(t){return new(t||e)(i.Lb(i.P))},e.\\u0275dir=i.Gb({type:e,selectors:[[\"\",\"ngTransclude\",\"\"]],inputs:{ngTransclude:\"ngTransclude\"}}),e})(),d=(()=>{class e{constructor(){this.type=\"tabs\",this.isKeysAllowed=!0,this.ariaLabel=\"Tabs\"}}return e.\\u0275fac=function(t){return new(t||e)},e.\\u0275prov=Object(i.Hb)({factory:function(){return new e},token:e,providedIn:\"root\"}),e})(),b=(()=>{class e{constructor(e,t,s){this.renderer=t,this.elementRef=s,this.clazz=!0,this.tabs=[],this.classMap={},Object.assign(this,e)}get vertical(){return this._vertical}set vertical(e){this._vertical=e,this.setClassMap()}get justified(){return this._justified}set justified(e){this._justified=e,this.setClassMap()}get type(){return this._type}set type(e){this._type=e,this.setClassMap()}get isKeysAllowed(){return this._isKeysAllowed}set isKeysAllowed(e){this._isKeysAllowed=e}ngOnDestroy(){this.isDestroyed=!0}addTab(e){this.tabs.push(e),e.active=1===this.tabs.length&&void 0===e.active}removeTab(e,t={reselect:!0,emit:!0}){const s=this.tabs.indexOf(e);if(-1!==s&&!this.isDestroyed){if(t.reselect&&e.active&&this.hasAvailableTabs(s)){const e=this.getClosestTabIndex(s);this.tabs[e].active=!0}t.emit&&e.removed.emit(e),this.tabs.splice(s,1),e.elementRef.nativeElement.parentNode&&this.renderer.removeChild(e.elementRef.nativeElement.parentNode,e.elementRef.nativeElement)}}keyNavActions(e,t){if(!this.isKeysAllowed)return;const s=Array.from(this.elementRef.nativeElement.querySelectorAll(\".nav-link\"));if(13!==e.keyCode&&\"Enter\"!==e.key&&32!==e.keyCode&&\"Space\"!==e.key)if(39!==e.keyCode&&\"RightArrow\"!==e.key)if(37!==e.keyCode&&\"LeftArrow\"!==e.key)if(36!==e.keyCode&&\"Home\"!==e.key)if(35!==e.keyCode&&\"End\"!==e.key){if((46===e.keyCode||\"Delete\"===e.key)&&this.tabs[t].removable){if(this.removeTab(this.tabs[t]),s[t+1])return void s[(t+1)%s.length].focus();s[s.length-1]&&s[0].focus()}}else{let i;e.preventDefault();let n=1,a=t;do{a-n<0?(a=s.length-1,i=s[a],n=0):i=s[a-n],n++}while(i.classList.contains(\"disabled\"));i.focus()}else{let t;e.preventDefault();let i=0;do{t=s[i%s.length],i++}while(t.classList.contains(\"disabled\"));t.focus()}else{let e,i=1,n=t;do{n-i<0?(n=s.length-1,e=s[n],i=0):e=s[n-i],i++}while(e.classList.contains(\"disabled\"));e.focus()}else{let e,i=1;do{e=s[(t+i)%s.length],i++}while(e.classList.contains(\"disabled\"));e.focus()}else e.preventDefault(),s[t%s.length].click()}getClosestTabIndex(e){const t=this.tabs.length;if(!t)return-1;for(let s=1;s<=t;s+=1){const t=e-s,i=e+s;if(this.tabs[t]&&!this.tabs[t].disabled)return t;if(this.tabs[i]&&!this.tabs[i].disabled)return i}return-1}hasAvailableTabs(e){const t=this.tabs.length;if(!t)return!1;for(let s=0;s<t;s+=1)if(!this.tabs[s].disabled&&s!==e)return!0;return!1}setClassMap(){this.classMap={\"nav-stacked\":this.vertical,\"flex-column\":this.vertical,\"nav-justified\":this.justified,[`nav-${this.type}`]:!0}}}return e.\\u0275fac=function(t){return new(t||e)(i.Lb(d),i.Lb(i.E),i.Lb(i.l))},e.\\u0275cmp=i.Fb({type:e,selectors:[[\"tabset\"]],hostVars:2,hostBindings:function(e,t){2&e&&i.Db(\"tab-container\",t.clazz)},inputs:{vertical:\"vertical\",justified:\"justified\",type:\"type\"},ngContentSelectors:c,decls:4,vars:3,consts:[[\"role\",\"tablist\",1,\"nav\",3,\"ngClass\",\"click\"],[3,\"ngClass\",\"active\",\"disabled\",\"keydown\",4,\"ngFor\",\"ngForOf\"],[1,\"tab-content\"],[3,\"ngClass\",\"keydown\"],[\"href\",\"javascript:void(0);\",\"role\",\"tab\",1,\"nav-link\",3,\"click\"],[3,\"ngTransclude\"],[\"class\",\"bs-remove-tab\",3,\"click\",4,\"ngIf\"],[1,\"bs-remove-tab\",3,\"click\"]],template:function(e,t){1&e&&(i.gc(),i.Rb(0,\"ul\",0),i.Yb(\"click\",function(e){return e.preventDefault()}),i.vc(1,r,5,17,\"li\",1),i.Qb(),i.Rb(2,\"div\",2),i.fc(3),i.Qb()),2&e&&(i.hc(\"ngClass\",t.classMap),i.Ab(\"aria-label\",t.ariaLabel),i.zb(1),i.hc(\"ngForOf\",t.tabs))},directives:[n.i,n.j,o,n.k],styles:[\"[_nghost-%COMP%]   .nav-tabs[_ngcontent-%COMP%]   .nav-item.disabled[_ngcontent-%COMP%]   a.disabled[_ngcontent-%COMP%]{cursor:default}\"]}),e})(),h=(()=>{class e{constructor(e,t,s){this.elementRef=t,this.renderer=s,this.selectTab=new i.n,this.deselect=new i.n,this.removed=new i.n,this.addClass=!0,this.role=\"tabpanel\",this.tabset=e,this.tabset.addTab(this)}get customClass(){return this._customClass}set customClass(e){this.customClass&&this.customClass.split(\" \").forEach(e=>{this.renderer.removeClass(this.elementRef.nativeElement,e)}),this._customClass=e?e.trim():null,this.customClass&&this.customClass.split(\" \").forEach(e=>{this.renderer.addClass(this.elementRef.nativeElement,e)})}get active(){return this._active}set active(e){this._active!==e&&(this.disabled&&e||!e?this._active&&!e&&(this.deselect.emit(this),this._active=e):(this._active=e,this.selectTab.emit(this),this.tabset.tabs.forEach(e=>{e!==this&&(e.active=!1)})))}get ariaLabelledby(){return this.id?`${this.id}-link`:\"\"}ngOnInit(){this.removable=this.removable}ngOnDestroy(){this.tabset.removeTab(this,{reselect:!1,emit:!1})}}return e.\\u0275fac=function(t){return new(t||e)(i.Lb(b),i.Lb(i.l),i.Lb(i.E))},e.\\u0275dir=i.Gb({type:e,selectors:[[\"tab\"],[\"\",\"tab\",\"\"]],hostVars:7,hostBindings:function(e,t){2&e&&(i.Ab(\"role\",t.role)(\"aria-labelledby\",t.ariaLabelledby)(\"id\",t.id),i.Db(\"tab-pane\",t.addClass)(\"active\",t.active))},inputs:{customClass:\"customClass\",active:\"active\",removable:\"removable\",heading:\"heading\",id:\"id\",disabled:\"disabled\"},outputs:{selectTab:\"selectTab\",deselect:\"deselect\",removed:\"removed\"},exportAs:[\"tab\"]}),e})(),u=(()=>{class e{static forRoot(){return{ngModule:e,providers:[]}}}return e.\\u0275mod=i.Jb({type:e}),e.\\u0275inj=i.Ib({factory:function(t){return new(t||e)},imports:[[n.b]]}),e})()}}]);","name":"common.c07f77c70b8bd7c83c1f.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[1],{\n\n/***/ \"44PX\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export NgTranscludeDirective */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return TabDirective; });\n/* unused harmony export TabHeadingDirective */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return TabsModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return TabsetComponent; });\n/* unused harmony export TabsetConfig */\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"fXoL\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"ofXK\");\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nfunction TabsetComponent_li_1_span_4_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵgetCurrentView */ \"Sb\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Rb\"](0, \"span\", 7);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵlistener */ \"Yb\"](\"click\", function TabsetComponent_li_1_span_4_Template_span_click_0_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵrestoreView */ \"pc\"](_r6); const tabz_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵnextContext */ \"bc\"]().$implicit; const ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵnextContext */ \"bc\"](); $event.preventDefault(); return ctx_r4.removeTab(tabz_r1); });\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵtext */ \"xc\"](1, \" \\u274C\");\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Qb\"]();\n    }\n}\nconst _c0 = function (a1) { return [\"nav-item\", a1]; };\nfunction TabsetComponent_li_1_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵgetCurrentView */ \"Sb\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Rb\"](0, \"li\", 3);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵlistener */ \"Yb\"](\"keydown\", function TabsetComponent_li_1_Template_li_keydown_0_listener($event) { _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵrestoreView */ \"pc\"](_r8); const i_r2 = ctx.index; const ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵnextContext */ \"bc\"](); return ctx_r7.keyNavActions($event, i_r2); });\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Rb\"](1, \"a\", 4);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵlistener */ \"Yb\"](\"click\", function TabsetComponent_li_1_Template_a_click_1_listener() { const tabz_r1 = ctx.$implicit; return tabz_r1.active = true; });\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Rb\"](2, \"span\", 5);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵtext */ \"xc\"](3);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Qb\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵtemplate */ \"vc\"](4, TabsetComponent_li_1_span_4_Template, 2, 0, \"span\", 6);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Qb\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Qb\"]();\n    }\n    if (rf & 2) {\n        const tabz_r1 = ctx.$implicit;\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵclassProp */ \"Db\"](\"active\", tabz_r1.active)(\"disabled\", tabz_r1.disabled);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵproperty */ \"hc\"](\"ngClass\", _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵpureFunction1 */ \"jc\"](15, _c0, tabz_r1.customClass || \"\"));\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵadvance */ \"zb\"](1);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵclassProp */ \"Db\"](\"active\", tabz_r1.active)(\"disabled\", tabz_r1.disabled);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵattribute */ \"Ab\"](\"aria-controls\", tabz_r1.id ? tabz_r1.id : \"\")(\"aria-selected\", !!tabz_r1.active)(\"id\", tabz_r1.id ? tabz_r1.id + \"-link\" : \"\");\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵadvance */ \"zb\"](1);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵproperty */ \"hc\"](\"ngTransclude\", tabz_r1.headingRef);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵadvance */ \"zb\"](1);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵtextInterpolate */ \"yc\"](tabz_r1.heading);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵadvance */ \"zb\"](1);\n        _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵproperty */ \"hc\"](\"ngIf\", tabz_r1.removable);\n    }\n}\nconst _c1 = [\"*\"];\nlet NgTranscludeDirective = /*@__PURE__*/ (() => {\n    class NgTranscludeDirective {\n        /**\n         * @param {?} viewRef\n         */\n        constructor(viewRef) {\n            this.viewRef = viewRef;\n        }\n        /**\n         * @param {?} templateRef\n         * @return {?}\n         */\n        set ngTransclude(templateRef) {\n            this._ngTransclude = templateRef;\n            if (templateRef) {\n                this.viewRef.createEmbeddedView(templateRef);\n            }\n        }\n        /* tslint:disable-next-line:no-any */\n        /**\n         * @return {?}\n         */\n        get ngTransclude() {\n            return this._ngTransclude;\n        }\n    }\n    NgTranscludeDirective.ɵfac = function NgTranscludeDirective_Factory(t) { return new (t || NgTranscludeDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ViewContainerRef */ \"P\"])); };\n    NgTranscludeDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineDirective */ \"Gb\"]({ type: NgTranscludeDirective, selectors: [[\"\", \"ngTransclude\", \"\"]], inputs: { ngTransclude: \"ngTransclude\" } });\n    return NgTranscludeDirective;\n})();\nif (false) {}\nlet TabsetConfig = /*@__PURE__*/ (() => {\n    class TabsetConfig {\n        constructor() {\n            /**\n             * provides default navigation context class: 'tabs' or 'pills'\n             */\n            this.type = 'tabs';\n            /**\n             * provides possibility to set keyNavigations enable or disable, by default is enable\n             */\n            this.isKeysAllowed = true;\n            /**\n             * aria label for tab list\n             */\n            this.ariaLabel = 'Tabs';\n        }\n    }\n    TabsetConfig.ɵfac = function TabsetConfig_Factory(t) { return new (t || TabsetConfig)(); };\n    /** @nocollapse */ TabsetConfig.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineInjectable */ \"Hb\"])({ factory: function TabsetConfig_Factory() { return new TabsetConfig(); }, token: TabsetConfig, providedIn: \"root\" });\n    return TabsetConfig;\n})();\nif (false) {}\nlet TabsetComponent = /*@__PURE__*/ (() => {\n    class TabsetComponent {\n        /**\n         * @param {?} config\n         * @param {?} renderer\n         * @param {?} elementRef\n         */\n        constructor(config, renderer, elementRef) {\n            this.renderer = renderer;\n            this.elementRef = elementRef;\n            this.clazz = true;\n            this.tabs = [];\n            this.classMap = {};\n            Object.assign(this, config);\n        }\n        /**\n         * if true tabs will be placed vertically\n         * @return {?}\n         */\n        get vertical() {\n            return this._vertical;\n        }\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set vertical(value) {\n            this._vertical = value;\n            this.setClassMap();\n        }\n        /**\n         * if true tabs fill the container and have a consistent width\n         * @return {?}\n         */\n        get justified() {\n            return this._justified;\n        }\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set justified(value) {\n            this._justified = value;\n            this.setClassMap();\n        }\n        /**\n         * navigation context class: 'tabs' or 'pills'\n         * @return {?}\n         */\n        get type() {\n            return this._type;\n        }\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set type(value) {\n            this._type = value;\n            this.setClassMap();\n        }\n        /**\n         * @return {?}\n         */\n        get isKeysAllowed() {\n            return this._isKeysAllowed;\n        }\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set isKeysAllowed(value) {\n            this._isKeysAllowed = value;\n        }\n        /**\n         * @return {?}\n         */\n        ngOnDestroy() {\n            this.isDestroyed = true;\n        }\n        /**\n         * @param {?} tab\n         * @return {?}\n         */\n        addTab(tab) {\n            this.tabs.push(tab);\n            tab.active = this.tabs.length === 1 && typeof tab.active === 'undefined';\n        }\n        /**\n         * @param {?} tab\n         * @param {?=} options\n         * @return {?}\n         */\n        removeTab(tab, options = { reselect: true, emit: true }) {\n            /** @type {?} */\n            const index = this.tabs.indexOf(tab);\n            if (index === -1 || this.isDestroyed) {\n                return;\n            }\n            // Select a new tab if the tab to be removed is selected and not destroyed\n            if (options.reselect && tab.active && this.hasAvailableTabs(index)) {\n                /** @type {?} */\n                const newActiveIndex = this.getClosestTabIndex(index);\n                this.tabs[newActiveIndex].active = true;\n            }\n            if (options.emit) {\n                tab.removed.emit(tab);\n            }\n            this.tabs.splice(index, 1);\n            if (tab.elementRef.nativeElement.parentNode) {\n                this.renderer.removeChild(tab.elementRef.nativeElement.parentNode, tab.elementRef.nativeElement);\n            }\n        }\n        /* tslint:disable-next-line: cyclomatic-complexity */\n        /**\n         * @param {?} event\n         * @param {?} index\n         * @return {?}\n         */\n        keyNavActions(event, index) {\n            if (!this.isKeysAllowed) {\n                return;\n            }\n            /** @type {?} */\n            const list = Array.from(this.elementRef.nativeElement.querySelectorAll('.nav-link'));\n            // const activeElList = list.filter((el: HTMLElement) => !el.classList.contains('disabled'));\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n                event.preventDefault();\n                /** @type {?} */\n                const currentTab = list[(index) % list.length];\n                currentTab.click();\n                return;\n            }\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 39 || event.key === 'RightArrow') {\n                /** @type {?} */\n                let nextTab;\n                /** @type {?} */\n                let shift = 1;\n                do {\n                    nextTab = list[(index + shift) % list.length];\n                    shift++;\n                } while (nextTab.classList.contains('disabled'));\n                nextTab.focus();\n                return;\n            }\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 37 || event.key === 'LeftArrow') {\n                /** @type {?} */\n                let previousTab;\n                /** @type {?} */\n                let shift = 1;\n                /** @type {?} */\n                let i = index;\n                do {\n                    if ((i - shift) < 0) {\n                        i = list.length - 1;\n                        previousTab = list[i];\n                        shift = 0;\n                    }\n                    else {\n                        previousTab = list[i - shift];\n                    }\n                    shift++;\n                } while (previousTab.classList.contains('disabled'));\n                previousTab.focus();\n                return;\n            }\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 36 || event.key === 'Home') {\n                event.preventDefault();\n                /** @type {?} */\n                let firstTab;\n                /** @type {?} */\n                let shift = 0;\n                do {\n                    firstTab = list[shift % list.length];\n                    shift++;\n                } while (firstTab.classList.contains('disabled'));\n                firstTab.focus();\n                return;\n            }\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 35 || event.key === 'End') {\n                event.preventDefault();\n                /** @type {?} */\n                let lastTab;\n                /** @type {?} */\n                let shift = 1;\n                /** @type {?} */\n                let i = index;\n                do {\n                    if ((i - shift) < 0) {\n                        i = list.length - 1;\n                        lastTab = list[i];\n                        shift = 0;\n                    }\n                    else {\n                        lastTab = list[i - shift];\n                    }\n                    shift++;\n                } while (lastTab.classList.contains('disabled'));\n                lastTab.focus();\n                return;\n            }\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 46 || event.key === 'Delete') {\n                if (this.tabs[index].removable) {\n                    this.removeTab(this.tabs[index]);\n                    if (list[index + 1]) {\n                        list[(index + 1) % list.length].focus();\n                        return;\n                    }\n                    if (list[list.length - 1]) {\n                        list[0].focus();\n                    }\n                }\n            }\n        }\n        /**\n         * @protected\n         * @param {?} index\n         * @return {?}\n         */\n        getClosestTabIndex(index) {\n            /** @type {?} */\n            const tabsLength = this.tabs.length;\n            if (!tabsLength) {\n                return -1;\n            }\n            for (let step = 1; step <= tabsLength; step += 1) {\n                /** @type {?} */\n                const prevIndex = index - step;\n                /** @type {?} */\n                const nextIndex = index + step;\n                if (this.tabs[prevIndex] && !this.tabs[prevIndex].disabled) {\n                    return prevIndex;\n                }\n                if (this.tabs[nextIndex] && !this.tabs[nextIndex].disabled) {\n                    return nextIndex;\n                }\n            }\n            return -1;\n        }\n        /**\n         * @protected\n         * @param {?} index\n         * @return {?}\n         */\n        hasAvailableTabs(index) {\n            /** @type {?} */\n            const tabsLength = this.tabs.length;\n            if (!tabsLength) {\n                return false;\n            }\n            for (let i = 0; i < tabsLength; i += 1) {\n                if (!this.tabs[i].disabled && i !== index) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * @protected\n         * @return {?}\n         */\n        setClassMap() {\n            this.classMap = {\n                'nav-stacked': this.vertical,\n                'flex-column': this.vertical,\n                'nav-justified': this.justified,\n                [`nav-${this.type}`]: true\n            };\n        }\n    }\n    TabsetComponent.ɵfac = function TabsetComponent_Factory(t) { return new (t || TabsetComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](TabsetConfig), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* Renderer2 */ \"E\"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ElementRef */ \"l\"])); };\n    TabsetComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineComponent */ \"Fb\"]({ type: TabsetComponent, selectors: [[\"tabset\"]], hostVars: 2, hostBindings: function TabsetComponent_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵclassProp */ \"Db\"](\"tab-container\", ctx.clazz);\n            }\n        }, inputs: { vertical: \"vertical\", justified: \"justified\", type: \"type\" }, ngContentSelectors: _c1, decls: 4, vars: 3, consts: [[\"role\", \"tablist\", 1, \"nav\", 3, \"ngClass\", \"click\"], [3, \"ngClass\", \"active\", \"disabled\", \"keydown\", 4, \"ngFor\", \"ngForOf\"], [1, \"tab-content\"], [3, \"ngClass\", \"keydown\"], [\"href\", \"javascript:void(0);\", \"role\", \"tab\", 1, \"nav-link\", 3, \"click\"], [3, \"ngTransclude\"], [\"class\", \"bs-remove-tab\", 3, \"click\", 4, \"ngIf\"], [1, \"bs-remove-tab\", 3, \"click\"]], template: function TabsetComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵprojectionDef */ \"gc\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Rb\"](0, \"ul\", 0);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵlistener */ \"Yb\"](\"click\", function TabsetComponent_Template_ul_click_0_listener($event) { return $event.preventDefault(); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵtemplate */ \"vc\"](1, TabsetComponent_li_1_Template, 5, 17, \"li\", 1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Qb\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Rb\"](2, \"div\", 2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵprojection */ \"fc\"](3);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Qb\"]();\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵproperty */ \"hc\"](\"ngClass\", ctx.classMap);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵattribute */ \"Ab\"](\"aria-label\", ctx.ariaLabel);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵadvance */ \"zb\"](1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵproperty */ \"hc\"](\"ngForOf\", ctx.tabs);\n            }\n        }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__[/* NgClass */ \"i\"], _angular_common__WEBPACK_IMPORTED_MODULE_1__[/* NgForOf */ \"j\"], NgTranscludeDirective, _angular_common__WEBPACK_IMPORTED_MODULE_1__[/* NgIf */ \"k\"]], styles: [\"[_nghost-%COMP%]   .nav-tabs[_ngcontent-%COMP%]   .nav-item.disabled[_ngcontent-%COMP%]   a.disabled[_ngcontent-%COMP%]{cursor:default}\"] });\n    return TabsetComponent;\n})();\nif (false) {}\nlet TabDirective = /*@__PURE__*/ (() => {\n    class TabDirective {\n        /**\n         * @param {?} tabset\n         * @param {?} elementRef\n         * @param {?} renderer\n         */\n        constructor(tabset, elementRef, renderer) {\n            this.elementRef = elementRef;\n            this.renderer = renderer;\n            /**\n             * fired when tab became active, $event:Tab equals to selected instance of Tab component\n             */\n            this.selectTab = new _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* EventEmitter */ \"n\"]();\n            /**\n             * fired when tab became inactive, $event:Tab equals to deselected instance of Tab component\n             */\n            this.deselect = new _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* EventEmitter */ \"n\"]();\n            /**\n             * fired before tab will be removed, $event:Tab equals to instance of removed tab\n             */\n            this.removed = new _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* EventEmitter */ \"n\"]();\n            this.addClass = true;\n            this.role = 'tabpanel';\n            this.tabset = tabset;\n            this.tabset.addTab(this);\n        }\n        /**\n         * if set, will be added to the tab's class attribute. Multiple classes are supported.\n         * @return {?}\n         */\n        get customClass() {\n            return this._customClass;\n        }\n        /**\n         * @param {?} customClass\n         * @return {?}\n         */\n        set customClass(customClass) {\n            if (this.customClass) {\n                this.customClass.split(' ').forEach(( /**\n                 * @param {?} cssClass\n                 * @return {?}\n                 */(cssClass) => {\n                    this.renderer.removeClass(this.elementRef.nativeElement, cssClass);\n                }));\n            }\n            this._customClass = customClass ? customClass.trim() : null;\n            if (this.customClass) {\n                this.customClass.split(' ').forEach(( /**\n                 * @param {?} cssClass\n                 * @return {?}\n                 */(cssClass) => {\n                    this.renderer.addClass(this.elementRef.nativeElement, cssClass);\n                }));\n            }\n        }\n        /**\n         * tab active state toggle\n         * @return {?}\n         */\n        get active() {\n            return this._active;\n        }\n        /**\n         * @param {?} active\n         * @return {?}\n         */\n        set active(active) {\n            if (this._active === active) {\n                return;\n            }\n            if ((this.disabled && active) || !active) {\n                if (this._active && !active) {\n                    this.deselect.emit(this);\n                    this._active = active;\n                }\n                return;\n            }\n            this._active = active;\n            this.selectTab.emit(this);\n            this.tabset.tabs.forEach(( /**\n             * @param {?} tab\n             * @return {?}\n             */(tab) => {\n                if (tab !== this) {\n                    tab.active = false;\n                }\n            }));\n        }\n        /**\n         * @return {?}\n         */\n        get ariaLabelledby() {\n            return this.id ? `${this.id}-link` : '';\n        }\n        /**\n         * @return {?}\n         */\n        ngOnInit() {\n            this.removable = this.removable;\n        }\n        /**\n         * @return {?}\n         */\n        ngOnDestroy() {\n            this.tabset.removeTab(this, { reselect: false, emit: false });\n        }\n    }\n    TabDirective.ɵfac = function TabDirective_Factory(t) { return new (t || TabDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](TabsetComponent), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ElementRef */ \"l\"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* Renderer2 */ \"E\"])); };\n    TabDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineDirective */ \"Gb\"]({ type: TabDirective, selectors: [[\"tab\"], [\"\", \"tab\", \"\"]], hostVars: 7, hostBindings: function TabDirective_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵattribute */ \"Ab\"](\"role\", ctx.role)(\"aria-labelledby\", ctx.ariaLabelledby)(\"id\", ctx.id);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵclassProp */ \"Db\"](\"tab-pane\", ctx.addClass)(\"active\", ctx.active);\n            }\n        }, inputs: { customClass: \"customClass\", active: \"active\", removable: \"removable\", heading: \"heading\", id: \"id\", disabled: \"disabled\" }, outputs: { selectTab: \"selectTab\", deselect: \"deselect\", removed: \"removed\" }, exportAs: [\"tab\"] });\n    return TabDirective;\n})();\nif (false) {}\nlet TabHeadingDirective = /*@__PURE__*/ (() => {\n    class TabHeadingDirective {\n        /* tslint:disable-next-line:no-any */\n        /**\n         * @param {?} templateRef\n         * @param {?} tab\n         */\n        constructor(templateRef, tab) {\n            tab.headingRef = templateRef;\n        }\n    }\n    TabHeadingDirective.ɵfac = function TabHeadingDirective_Factory(t) { return new (t || TabHeadingDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* TemplateRef */ \"L\"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Lb\"](TabDirective)); };\n    TabHeadingDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineDirective */ \"Gb\"]({ type: TabHeadingDirective, selectors: [[\"\", \"tabHeading\", \"\"]] });\n    return TabHeadingDirective;\n})();\nif (false) {}\nlet TabsModule = /*@__PURE__*/ (() => {\n    class TabsModule {\n        /**\n         * @return {?}\n         */\n        static forRoot() {\n            return {\n                ngModule: TabsModule,\n                providers: []\n            };\n        }\n    }\n    TabsModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineNgModule */ \"Jb\"]({ type: TabsModule });\n    TabsModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineInjector */ \"Ib\"]({ factory: function TabsModule_Factory(t) { return new (t || TabsModule)(); }, imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__[/* CommonModule */ \"b\"]]] });\n    return TabsModule;\n})();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵsetNgModuleScope */ \"sc\"](TabsModule, { declarations: function () { return [NgTranscludeDirective, TabDirective, TabsetComponent, TabHeadingDirective]; }, imports: function () { return [_angular_common__WEBPACK_IMPORTED_MODULE_1__[/* CommonModule */ \"b\"]]; }, exports: function () { return [TabDirective, TabsetComponent, TabHeadingDirective, NgTranscludeDirective]; } }); })();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n//# sourceMappingURL=ngx-bootstrap-tabs.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}